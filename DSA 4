PRACTICAL NO.4

Aim: Tree.

0.1 Trees.

A] Write Python Program to implement tree data structure and demonstrate depth- first traversal.

CODE:

graph = {
'A': ['B', 'c'],
'B': ['D', 'E'],
'C': ['F'],
'D': [],
'E': ['F'],
F:[]
}
visited = set() # Set to keep track of visited nodes,
def dfs(visited, graph, node):
  if node not in visited:
     print (node)
     visited.add(node)
     for neighbour in graph[node]:
        dfs(visited, graph, neighbour)
dfs(visited, graph, 'A')


B) Write Python Program to implement tree data structure and demonstrate breadth- first traversal.

graph={
'A': ['B', 'C'],
'B': ['D', 'E'],
'C': ['F'],
'D': [],
'E': ['F'],
'F': []}
visited =[] #List to keep track of visited nodes.
queue =[] #Initialize a queue
def bfs (visited, graph, node):
  visited.append(node)
  queue.append(node)
  while queue:
   s = queue.pop(0)
   print (s, end = "")
   for neighbour in graph[s]:
     if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
bfs (visited, graph, 'A')
